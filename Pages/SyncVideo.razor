@page "/"
@implements IAsyncDisposable
@inject NavigationManager Navigation
@using Microsoft.AspNetCore.SignalR.Client
@inject IJSRuntime JS
@using VideoHome.Data;
@using Excubo.Blazor.TreeViews
@using System.Diagnostics
@using SoloX.BlazorLayout.Core
@using SoloX.BlazorLayout.Containers.Dock
@using Microsoft.Extensions.Configuration
@inject IConfiguration Configuration;
@using Microsoft.Extensions.Logging
@using YoutubeExplode;
@using YoutubeExplode.Videos.Streams;
@inject ILogger<SyncVideo> Logger

<link rel="stylesheet" href="css/plyr.css" />

<DockContainer Fill="Fill.Full" Proportion="25">
    <DockPanel Class="px-4" Side="Side.Right">

        <div>Watch Youtube stream:</div>
        <div class="file-input-zone">
            <input type="text" @bind="streamInputBoxContent" />
            <button onclick="@PlayYoutube">Play</button>
        </div><br>

        <div>Local Files:</div><br>
        @if (!isUploading)
        {
            <div class="file-input-zone">
                Upload:
                <InputFile OnChange="@UploadFiles" multiple title="Upload video" />
            </div><br>
        }
        else
        {
            <div>Uploading...</div><br>
        }
        <TreeView Items="TreeViewItems" GetChildren="(item) => item.Children" InitiallyCollapsed="true">
            <ItemTemplate>
                <div @onclick="()=>ItemClicked(context.Item)" class="treeviewline">
                    @if (context.Item.ItemType == FileTreeViewItem.NodeType.Folder)
                    {
                        <MatIcon Icon="folder" />
                    }
                    else
                    {
                        <MatIcon Icon="insert_drive_file" />
                    }
                    @context.Item.Text
                </div>
            </ItemTemplate>
        </TreeView>
    </DockPanel>

    <div class="d-flex flex-column p-2 align-content-center">
        <BlazoredVideo @ref="videoRef"  id="playerx"
            width="1280" height="720" 
            controls playsinline
            EventFired="OnEvent"
            VideoEventOptions="options" 
            data-plyr-config='{ "disableContextMenu": "false" }'>
            <source src=@videoSource type="video/mp4" />
            <!-- Caption files -->
            @if (videoCaptions != null && videoCaptions.Any())
            {
                foreach (var cc in videoCaptions)
                {
                    <track kind="subtitles"
                        label="English"
                        srclang="en"
                        src=@cc
                        default />
                }
            }
        </BlazoredVideo>
    </div>

</DockContainer>


@code {
    private Dictionary<VideoEvents, VideoStateOptions> options = new();
    private VideoState videoState = new();

    private DateTimeOffset lastUpdateRecieved = DateTimeOffset.MinValue;

    private BlazoredVideo videoRef;
    private string? streamInputBoxContent;
    private HubConnection? hubConnection;
    string? videoSource = "";
    List<string> videoCaptions = new() {""};

    private YoutubeClient youtube = new();

    private async void PlayYoutube()
    {
        var url = streamInputBoxContent;
        if(url == null || !url.Contains("youtube."))
            return;
            
        Console.WriteLine($"Getting youtube video for {url}");
        var streamManifest = await youtube.Videos.Streams.GetManifestAsync(url);
        var streamInfo = streamManifest.GetMuxedStreams().GetWithHighestVideoQuality();
        Console.WriteLine(streamInfo.Url);
        await SetVideoSource(streamInfo.Url, false);
    }

    private async Task ItemClicked(FileTreeViewItem item)
    {
        if (item.ItemType == FileTreeViewItem.NodeType.File)
        {
            Debug.WriteLine($"Item pressed: {item.Path}");
            await SetVideoSource(item.Path, true);
        }
        else
        {
            Debug.WriteLine($"Folder clicked!");
        }
    }

    private async Task SetVideoSource(string src, bool setCaptions)
    {
            videoSource = src;
            videoCaptions = new() { setCaptions? Path.ChangeExtension(src, ".vtt") : "" };
            await videoRef.PausePlayback();
            await SendState();

            await videoRef.ReloadControl();
            await InvokeAsync(StateHasChanged);
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        IJSObjectReference Plyr;
        IJSObjectReference Main;    

        if (firstRender)
        {
            Plyr = await JS.InvokeAsync<IJSObjectReference>(
                        "import", "./plyr.js");
            Main = await JS.InvokeAsync<IJSObjectReference>(
                        "import", "./plyr-loder.js");
            await Main.InvokeVoidAsync("load", "playerx").AsTask();

            await hubConnection.SendAsync("RequestState");
        }
    }

    private long maxFileSize = 2L * 1024 * 1024 * 1024;
    private int maxAllowedFiles = 3;
    private bool isUploading;
    private string[] supportedFormats = {".mp4", ".webm"};
    private async Task UploadFiles(InputFileChangeEventArgs e)
    {
        isUploading = true;

        foreach (var file in e.GetMultipleFiles(maxAllowedFiles))
        {
            try
            {
                var dir =  Path.Combine(Configuration.GetSection("VideoMapping")["VideoPath"], "uploads");
                Directory.CreateDirectory(dir);
                var path = Path.Combine(dir, file.Name);

                if(!supportedFormats.Any(fo => path.EndsWith(fo)))
                {
                    await JS.InvokeVoidAsync("alert", $"File format not supported!\n Supported file formats are: {string.Join(" ", supportedFormats)}");
                    continue;
                }
                if(File.Exists(path))
                {
                    await JS.InvokeVoidAsync("alert", $"File called {file.Name} already exists!");
                    continue;
                }


                await using FileStream fs = new(path, FileMode.Create);
                await file.OpenReadStream(maxFileSize).CopyToAsync(fs);
            }
            catch (Exception ex)
            {
                Logger.LogError("File: {Filename} Error: {Error}", 
                    file.Name, ex.Message);
            }
        }

        isUploading = false;
        RefreshFileTree();
    }
    private void RefreshFileTree()
    {

        TreeViewItems = FileTreeViewItem.EnumerateFilesWithRootMapping(Configuration.GetSection("VideoMapping")["VideoPath"], 
                Configuration.GetSection("VideoMapping")["MapTo"]);

    }

    protected override async Task OnInitializedAsync()
    {
        RefreshFileTree();
        var allOptionsEnabled = new VideoStateOptions() { All = true };
        foreach (var item in (VideoEvents[])(Enum.GetValues(typeof(VideoEvents))))
        {
            if (item != VideoEvents.NotSet)
            {
                options[item] = allOptionsEnabled;
            }
        }

        hubConnection = new HubConnectionBuilder()
            .WithUrl(Navigation.ToAbsoluteUri("/syncvideohub"))
            .Build();

        hubConnection.On<int, DateTimeOffset>("Ping", async (n, timestamp) =>
        {
            await hubConnection.SendAsync("Pong", n, timestamp);
        });

        hubConnection.On<VideoStateDto>("ReceiveState", StateRecieved);

        await hubConnection.StartAsync();

    }

    private VideoStateDto GetStateDto()
    {
        return new VideoStateDto()
        {
            LastUpdated = DateTimeOffset.UtcNow,
            IsPlaying = !videoState.Paused,
            Source = videoSource,
            Captions = videoCaptions,
            VideoTimestamp = videoState.CurrentTime
        };
    }

    private async Task StateRecieved(VideoStateDto newstate)
    {
        if (videoRef is null)
            return;
        Console.WriteLine($"Client: State recieved. {newstate.Source?.Split('/').LastOrDefault()} {newstate.IsPlaying} {newstate.VideoTimestamp}");

        if(newstate.Source != videoSource)
        {
            Console.WriteLine($"Client: Setting video source.");
            videoSource = newstate.Source;
            videoCaptions = newstate.Captions;

            if(!string.IsNullOrEmpty(videoSource))
            {
                await InvokeAsync(StateHasChanged);
                await videoRef.ReloadControl();
            }
        }
        if(Math.Abs(newstate.VideoTimestamp - videoState.CurrentTime) > 0.5)
        {
            Console.WriteLine($"Client: Setting time.");
            await videoRef.SetCurrentTimeAsync(newstate.VideoTimestamp); 
        }
        @* if (newstate.IsPlaying == videoState.Paused)
        { *@
            if (newstate.IsPlaying)
            {
                Console.WriteLine($"Client: Pausing playback.");
                await videoRef.StartPlayback();
            }
            else
            {
                Console.WriteLine($"Client: Pausing playback.");
                await videoRef.PausePlayback();
            }
        @* } *@
        lastUpdateRecieved = DateTimeOffset.Now;
        await InvokeAsync(StateHasChanged);
    }

    private async Task SendState()
    {
        if ((DateTimeOffset.Now - lastUpdateRecieved).TotalSeconds < 0.7)
            return;

        VideoStateDto newstate = GetStateDto(); 
        Console.WriteLine($"Client: Sending state. {newstate.Source?.Split('/')?.LastOrDefault()} {newstate.IsPlaying} {newstate.VideoTimestamp}");

        await hubConnection.SendAsync("UpdateState", newstate);
    }

    private async void OnEvent(VideoEventData videoData)
    {
        videoState = videoData.State;

        
        switch (videoData.EventName)
        {
            case VideoEvents.Play:
            case VideoEvents.Playing:
            case VideoEvents.Pause:
            case VideoEvents.Seeking:
            case VideoEvents.Seeked:
                Console.WriteLine($"Client: OnEvent: {videoData.EventName} {videoState.CurrentTime}");
                await SendState();
                break;

            default:
            break;
        }
        @* StateHasChanged(); *@
    }

    private List<FileTreeViewItem> TreeViewItems;

    public async ValueTask DisposeAsync()
    {
        Console.WriteLine("Client: Disposing razor page.");
        if (hubConnection is not null)
        {
            await hubConnection.DisposeAsync();
        }
    }
}